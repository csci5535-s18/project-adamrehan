\documentclass[11pt]{exam}
\usepackage[margin=1in]{geometry}
\usepackage{amsmath,amsthm,amssymb}
\usepackage{mathptmx}

\usepackage{xspace}
\usepackage{tabularx}
\usepackage{amsmath}
\usepackage{mathpartir} %% for inference rules

%% Listings
\usepackage{listings}
\lstdefinestyle{default}{%
  basicstyle=\ttfamily,%
  commentstyle=\sl,%
  keywordstyle=\bf,%
  columns=fullflexible,%
  keepspaces=true,%
  mathescape%
}
\lstset{style=default}
\newcommand{\ocaml}[1]{\lstset{language=[Objective]Caml}\lstinline~#1~}
\lstnewenvironment{OCaml}
  {\lstset{language=[Objective]Caml}}
  {}

\title{Final Project Checkpoint\\Formalized Algebra from Text}

\author{Adam Wiemerslage and Rehan Ahmed}

%% Number questions by section
\renewcommand{\thequestion}{\thesection.\arabic{question}}

%% toggle math mode and text mode for tabular and array
\newcolumntype{C}{>{$}c<{$}}
\newcolumntype{L}{>{$}l<{$}}
\newcolumntype{R}{>{$}r<{$}}

\newcommand{\fmtkw}[1]{\mathtt{#1}}

\newcommand{\Typ}{\ensuremath{\mathsf{Typ}}}
\newcommand{\typ}{\ensuremath{\mathit{\tau}}}
\newcommand{\numtyp}{\ensuremath{\fmtkw{num}}}
\newcommand{\booltyp}{\ensuremath{\fmtkw{bool}}}

\newcommand{\Expr}{\ensuremath{\mathsf{Exp}}}
\newcommand{\expr}{\ensuremath{\mathit{e}}}

\newcommand{\addra}[1]{\ensuremath{\fmtkw{addr}[#1]}}
\newcommand{\addr}{\ensuremath{\mathit{a}}}
\newcommand{\numa}[1]{\ensuremath{\fmtkw{num}[#1]}}
\newcommand{\num}{\ensuremath{\mathit{n}}}
\newcommand{\boola}[1]{\ensuremath{\fmtkw{bool}[#1]}}
\newcommand{\bool}{\ensuremath{\mathit{b}}}
\newcommand{\plusa}[2]{\ensuremath{\fmtkw{plus}(#1; #2)}}
\newcommand{\minusa}[2]{\ensuremath{\fmtkw{minus}(#1; #2)}}
\newcommand{\plusc}[2]{\ensuremath{#1 \mathbin{\fmtkw{+}} #2}}
\newcommand{\minusc}[2]{\ensuremath{#1 \mathbin{\fmtkw{-}} #2}}
\newcommand{\timesa}[2]{\ensuremath{\fmtkw{times}(#1; #2)}}
\newcommand{\dividea}[2]{\ensuremath{\fmtkw{divide}(#1; #2)}}
\newcommand{\timesc}[2]{\ensuremath{#1 \mathbin{\fmtkw{*}} #2}}
\newcommand{\eqa}[2]{\ensuremath{\fmtkw{eq}(#1; #2)}}
\newcommand{\eqc}[2]{\ensuremath{#1 \mathrel{\fmtkw{==}} #2}}
\newcommand{\lea}[2]{\ensuremath{\fmtkw{le}(#1; #2)}}
\newcommand{\lec}[2]{\ensuremath{#1 \mathrel{\fmtkw{<=}} #2}}
\newcommand{\nota}[1]{\ensuremath{\fmtkw{not}(#1)}}
\newcommand{\notc}[1]{\ensuremath{\mathord{\fmtkw{!}}#1}}
\newcommand{\anda}[2]{\ensuremath{\fmtkw{and}(#1; #2)}}
\newcommand{\andc}[2]{\ensuremath{#1 \mathbin{\fmtkw{\&\&}} #2}}
\newcommand{\ora}[2]{\ensuremath{\fmtkw{or}(#1; #2)}}
\newcommand{\orc}[2]{\ensuremath{#1 \mathbin{\fmtkw{||}} #2}}

\newcommand{\Cmd}{\ensuremath{\mathsf{Cmd}}}
\newcommand{\cmd}{\ensuremath{\mathit{c}}}
\newcommand{\skipa}{\ensuremath{\fmtkw{skip}}}
\newcommand{\seta}[2]{\ensuremath{\fmtkw{set}[#1](#2)}}
\newcommand{\setc}[2]{\ensuremath{#1 \mathrel{\fmtkw{:=}} #2}}
\newcommand{\seqa}[2]{\ensuremath{\fmtkw{seq}(#1; #2)}}
\newcommand{\seqc}[2]{\ensuremath{#1\fmtkw{;}\;#2}}
\newcommand{\ifa}[3]{\ensuremath{\fmtkw{if}(#1; #2; #3)}}
\newcommand{\ifc}[3]{\ensuremath{\fmtkw{if}\;#1\;\fmtkw{then}\;#2\;\fmtkw{else}\;#3}}
\newcommand{\whilea}[2]{\ensuremath{\fmtkw{while}(#1; #2)}}
\newcommand{\whilec}[2]{\ensuremath{\fmtkw{while}\;#1\;\fmtkw{do}\;#2}}
\newcommand{\printa}[1]{\ensuremath{\fmtkw{print}(#1)}}
\newcommand{\printc}[1]{\ensuremath{\fmtkw{print}\; #1}}


\newcommand{\Addr}{\ensuremath{\mathsf{Addr}}}

\newcommand{\store}{\ensuremath{\sigma}}
\newcommand{\storelet}[2]{\ensuremath{#1 \hookrightarrow #2}}
\newcommand{\xstore}[3]{#1, \storelet{#2}{#3}}

\newcommand{\IMP}{\textbf{\textsf{IMP-1}}\xspace}

\newcommand{\E}{\textbf{\textsf{E}}\xspace}
\newcommand{\T}{\textbf{\textsf{T}}\xspace}
\renewcommand{\P}{\textbf{\textsf{P}}\xspace}
\renewcommand{\S}{\textbf{\textsf{S}}\xspace}
\newcommand{\ET}{\textbf{\textsf{ET}}\xspace}
\newcommand{\ETP}{\textbf{\textsf{ETP}}\xspace}
\newcommand{\ETPS}{\textbf{\textsf{ETPS}}\xspace}

\newcommand{\state}[2]{\langle #1, #2 \rangle}

\newcommand{\hasType}[2]{\ensuremath{#1 : #2}}
\newcommand{\hypJ}[2]{\ensuremath{#1 \vdash #2}}
\newcommand{\isOk}[1]{\ensuremath{#1\;\mathsf{ok}}}
\newcommand{\eval}[2]{\ensuremath{#1 \Downarrow #2}}
\newcommand{\step}[2]{\ensuremath{#1 \longmapsto #2}}
\newcommand{\stepspap}[3][\typ]{\ensuremath{#2 \hookrightarrow_{:#1} #3}}
\newcommand{\isVal}[1]{\ensuremath{#1\;\mathsf{val}}}
\newcommand{\isFinal}[1]{\ensuremath{#1\;\mathsf{final}}}
\newcommand{\isFloat}[1]{\ensuremath{#1 : \mathsf{float}}}
\newcommand{\floata}[1]{\ensuremath{\mathsf{float [#1]}}}

\newcommand{\even}{\operatorname{even}}
\newtheorem{problem}{Example}
\pagestyle{plain}
\begin{document}
\maketitle
\section{Abstract}
In this project, we are proposing to solve algebraic word problems in a way similar to Kushman et al [cite Learning to Automatically Solve Algebra Word Problems]. However, rather than relying on a rule based approach [look at above paper for citations to rule based approaches], or a mapping function to a set of templates (as in Kushman et al), we are proposing a slightly different method. In this method, we will learn a mapping from the input sequence of words, to a set of triples of potential expressions, via a dependency parse of the text. Then, rather than mapping each entity or verb in the text to a template, we will map each element in the triple to a type in our language, based on a probabilistic model.

Finally, our programming language will be implemented to solve the expressions provided by our NLP model, based on a simple operational semantics we have created for solving such problems. The target language will be the simple \IMP language.\\\\

\section{Example}
\begin{problem}
	Pooja has 3 apples. She eats one apple. How many apples does Pooja have now?
\end{problem}
We attempt to translate the sample problem's text into the following commands:

\[\begin{array}{lrcllL}
\textit{Pooja has 3 apples} & -> & \setc{a_p}{3}
\\
\textit{She eats one apple} & -> & \setc{a_p}{a_p - 1}
\\
\textit{How many apples does Pooja have now?} & -> & \printc{a_p}
\end{array}\]

And since these are sequence of steps we end up with:
\[
	\seqc{\setc{a_p}{3}}{\seqc{\setc{a_p}{\minusc{a_p}{1}}}{\printc{a_p}}}
\]

More formally:
\[
\seqa{\seta{a_p}{3}}{\seqa{\seta{a_p}{\minusa{a_p}{1}}}{\printa{a_p}}}
\]

\fbox{\inferrule{}{\isVal{e}}}\\

\section{Language: \IMP}
%\begin{mathpar}
%	\inferrule[ ]{ }{
%		\isFloat{e}
%	}
%\end{mathpar}\\

\fbox{\inferrule{}{\hasType{e}{\tau}}}\\

\begin{mathpar}
	\inferrule[ ]{ }
    {
		\isFloat{\addra{\addr}}
	}
    
    \inferrule[ ]{ }
    {
		\isFloat{\floata{f}}
	}
    
    \inferrule[ ]{\isFloat{e_1} \\ 
    \isFloat{e_2}}
    {
		\isFloat{\plusa{e_1}{e_2}}
	}
    
    \inferrule[ ]{\isFloat{e_1} \ 
    \isFloat{e_2}}
    {
		\isFloat{\minusa{e_1}{e_2}}
	}
    
    \inferrule[ ]{\isFloat{e_1} \ 
    \isFloat{e_2}}
    {
		\isFloat{\timesa{e_1}{e_2}}
	}
    
    \inferrule[ ]{\isFloat{e_1} \ 
    \isFloat{e_2}}
    {
		\isFloat{\dividea{e_1}{e_2}}
	}
\end{mathpar}\\

\fbox{\inferrule{}{c: ok}} \\\\

\begin{mathpar} 
	\inferrule[]{
    	\isFloat{e}
    }{
		\isOk{\seta{\addr}{e}}
    }

	\inferrule[]{ }{
		\isOk{\skipa}
	}

 	\inferrule[]{
 		\isOk{c_1} \ \ \isOk{c_2}
   	}{
		\isOk{\seqa{c_1}{c_2}}
	}
	
	\inferrule[]{
		\isFloat{e}
	}{
	\isOk{\printa{e}}
	}


\end{mathpar}
\hspace{6cm}Syntax chart:
\[\begin{array}{lrcllL}
\Typ & \typ & ::= & \numtyp & \numtyp & numbers
\\
&&& \booltyp & \booltyp & booleans
\\
\Expr & \expr & ::= & \addra{\addr} & \addr & addresses (or ``assignables'') 
\\ 
&&& \numa{\num} & \num & numeral
\\
&&& \boola{\bool} & \bool & boolean
\\
&&& \plusa{\expr_1}{\expr_2} & \plusc{\expr_1}{\expr_2} & addition
\\
&&& \timesa{\expr_1}{\expr_2} & \timesc{\expr_1}{\expr_2} & multiplication
\\
&&& \eqa{\expr_1}{\expr_2} & \eqc{\expr_1}{\expr_2} & equal
\\
&&& \lea{\expr_1}{\expr_2} & \lec{\expr_1}{\expr_2} & less-than-or-equal
\\
&&& \nota{\expr_1} & \notc{\expr_1} & negation
\\
&&& \anda{\expr_1}{\expr_2} & \andc{\expr_1}{\expr_2} & conjunction
\\
&&& \ora{\expr_1}{\expr_2} & \orc{\expr_1}{\expr_2} & disjunction
\\
\Cmd & \cmd & ::= & \seta{\addr}{\expr} & \setc{\addr}{\expr} & assignment
\\
&&& \skipa & \skipa & skip
\\
&&& \seqa{\cmd_1}{\cmd_2} & \seqc{\cmd_1}{\cmd_2} & sequencing
\\
&&& \ifa{\expr}{\cmd_1}{\cmd_2} & \ifc{\expr}{\cmd_1}{\cmd_2} & conditional
\\
&&& \whilea{\expr}{\cmd_1} & \whilec{\expr}{\cmd_1} & looping
\\
&&& \printa{e} & \printc{e} & printing
\\
\Addr & \addr
\end{array}\]
\end{document}